{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Matias\\\\nexus-pro\\\\src\\\\context\\\\AuthContext.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, createContext, useCallback, useMemo } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst API_URL = 'http://127.0.0.1:8000/api';\n\n// --- Función para decodificar JWT de forma segura ---\nconst decodificarToken = token => {\n  try {\n    return JSON.parse(atob(token.split('.')[1]));\n  } catch (e) {\n    console.error(\"Error al decodificar el token\", e);\n    return null;\n  }\n};\nexport const ContextoAuth = /*#__PURE__*/createContext();\nexport const ProveedorAuth = ({\n  children\n}) => {\n  _s();\n  // Se inicializa el estado desde localStorage para mantener la sesión\n  const [tokensAuth, setTokensAuth] = useState(() => localStorage.getItem('tokensAuth') ? JSON.parse(localStorage.getItem('tokensAuth')) : null);\n  const [usuario, setUsuario] = useState(() => {\n    const tokens = localStorage.getItem('tokensAuth');\n    if (!tokens) return null;\n    try {\n      return decodificarToken(JSON.parse(tokens).access);\n    } catch (e) {\n      return null;\n    }\n  });\n  const [cargandoInicial, setCargandoInicial] = useState(true);\n  const iniciarSesion = async (nombreUsuario, contrasena) => {\n    try {\n      const response = await fetch(`${API_URL}/token/`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          username: nombreUsuario,\n          password: contrasena\n        })\n      });\n      const data = await response.json();\n      if (response.ok) {\n        const usuarioDecodificado = decodificarToken(data.access);\n        setTokensAuth(data);\n        setUsuario(usuarioDecodificado);\n        localStorage.setItem('tokensAuth', JSON.stringify(data));\n      } else {\n        alert('Usuario o contraseña incorrectos.');\n      }\n    } catch (error) {\n      alert('Error de conexión con el servidor.');\n    }\n  };\n  const cerrarSesion = useCallback(() => {\n    setTokensAuth(null);\n    setUsuario(null);\n    localStorage.removeItem('tokensAuth');\n  }, []);\n\n  // La función para actualizar el token ahora es más robusta\n  const actualizarToken = useCallback(async () => {\n    const tokensActuales = JSON.parse(localStorage.getItem('tokensAuth'));\n    if (!(tokensActuales !== null && tokensActuales !== void 0 && tokensActuales.refresh)) {\n      cerrarSesion();\n      return;\n    }\n    try {\n      const response = await fetch(`${API_URL}/token/refresh/`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          'refresh': tokensActuales.refresh\n        })\n      });\n      const data = await response.json();\n      if (response.ok) {\n        // Se actualiza el token de acceso manteniendo el de refresco\n        const nuevosTokens = {\n          ...tokensActuales,\n          access: data.access\n        };\n        setTokensAuth(nuevosTokens);\n        setUsuario(decodificarToken(data.access));\n        localStorage.setItem('tokensAuth', JSON.stringify(nuevosTokens));\n      } else {\n        // Si el refresh token también falló, cerramos sesión\n        cerrarSesion();\n      }\n    } catch {\n      cerrarSesion();\n    }\n  }, [cerrarSesion]);\n\n  // --- LÓGICA DE REFRESCO INTELIGENTE ---\n  useEffect(() => {\n    // Si no hay tokens, no hacemos nada.\n    if (!tokensAuth) {\n      setCargandoInicial(false);\n      return;\n    }\n\n    // Decodificamos el token para saber cuándo expira.\n    const tokenInfo = decodificarToken(tokensAuth.access);\n    const ahora = Date.now() / 1000; // Tiempo actual en segundos\n\n    // El tiempo de vida del token es la fecha de expiración menos el tiempo actual.\n    // Restamos 60 segundos para refrescar 1 minuto antes y evitar problemas.\n    let tiempoRestante = (tokenInfo.exp - ahora - 60) * 1000;\n\n    // Nos aseguramos de no tener tiempos negativos\n    if (tiempoRestante < 0) tiempoRestante = 0;\n\n    // Creamos un temporizador que llamará a actualizarToken()\n    const timeout = setTimeout(() => {\n      actualizarToken();\n    }, tiempoRestante);\n\n    // Se marca la carga inicial como completa\n    setCargandoInicial(false);\n\n    // Limpiamos el temporizador si el componente se desmonta o los tokens cambian\n    return () => clearTimeout(timeout);\n  }, [tokensAuth, actualizarToken]);\n\n  // Memorizamos el valor del contexto para evitar re-renders innecesarios en los componentes hijos\n  const datosContexto = useMemo(() => ({\n    usuario,\n    tokensAuth,\n    iniciarSesion,\n    cerrarSesion\n  }), [usuario, tokensAuth, cerrarSesion]);\n  return /*#__PURE__*/_jsxDEV(ContextoAuth.Provider, {\n    value: datosContexto,\n    children: cargandoInicial ? /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"min-h-screen flex items-center justify-center\",\n      children: \"Cargando...\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 130,\n      columnNumber: 32\n    }, this) : children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 129,\n    columnNumber: 9\n  }, this);\n};\n_s(ProveedorAuth, \"YO78XiNbp9iRUtnhov0r0KOxzLA=\");\n_c = ProveedorAuth;\nvar _c;\n$RefreshReg$(_c, \"ProveedorAuth\");","map":{"version":3,"names":["React","useState","useEffect","createContext","useCallback","useMemo","jsxDEV","_jsxDEV","API_URL","decodificarToken","token","JSON","parse","atob","split","e","console","error","ContextoAuth","ProveedorAuth","children","_s","tokensAuth","setTokensAuth","localStorage","getItem","usuario","setUsuario","tokens","access","cargandoInicial","setCargandoInicial","iniciarSesion","nombreUsuario","contrasena","response","fetch","method","headers","body","stringify","username","password","data","json","ok","usuarioDecodificado","setItem","alert","cerrarSesion","removeItem","actualizarToken","tokensActuales","refresh","nuevosTokens","tokenInfo","ahora","Date","now","tiempoRestante","exp","timeout","setTimeout","clearTimeout","datosContexto","Provider","value","className","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Matias/nexus-pro/src/context/AuthContext.js"],"sourcesContent":["import React, { useState, useEffect, createContext, useCallback, useMemo } from 'react';\r\n\r\nconst API_URL = 'http://127.0.0.1:8000/api';\r\n\r\n// --- Función para decodificar JWT de forma segura ---\r\nconst decodificarToken = (token) => {\r\n    try {\r\n        return JSON.parse(atob(token.split('.')[1]));\r\n    } catch (e) {\r\n        console.error(\"Error al decodificar el token\", e);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport const ContextoAuth = createContext();\r\n\r\nexport const ProveedorAuth = ({ children }) => {\r\n    // Se inicializa el estado desde localStorage para mantener la sesión\r\n    const [tokensAuth, setTokensAuth] = useState(() => localStorage.getItem('tokensAuth') ? JSON.parse(localStorage.getItem('tokensAuth')) : null);\r\n    const [usuario, setUsuario] = useState(() => {\r\n        const tokens = localStorage.getItem('tokensAuth');\r\n        if (!tokens) return null;\r\n        try {\r\n            return decodificarToken(JSON.parse(tokens).access);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    });\r\n    \r\n    const [cargandoInicial, setCargandoInicial] = useState(true);\r\n\r\n    const iniciarSesion = async (nombreUsuario, contrasena) => {\r\n        try {\r\n            const response = await fetch(`${API_URL}/token/`, { \r\n                method: 'POST', \r\n                headers: { 'Content-Type': 'application/json' }, \r\n                body: JSON.stringify({ username: nombreUsuario, password: contrasena }) \r\n            });\r\n            const data = await response.json();\r\n            if (response.ok) { \r\n                const usuarioDecodificado = decodificarToken(data.access);\r\n                setTokensAuth(data); \r\n                setUsuario(usuarioDecodificado); \r\n                localStorage.setItem('tokensAuth', JSON.stringify(data)); \r\n            } else { \r\n                alert('Usuario o contraseña incorrectos.'); \r\n            }\r\n        } catch (error) {\r\n            alert('Error de conexión con el servidor.');\r\n        }\r\n    };\r\n\r\n    const cerrarSesion = useCallback(() => { \r\n        setTokensAuth(null); \r\n        setUsuario(null); \r\n        localStorage.removeItem('tokensAuth'); \r\n    }, []);\r\n\r\n    // La función para actualizar el token ahora es más robusta\r\n    const actualizarToken = useCallback(async () => {\r\n        const tokensActuales = JSON.parse(localStorage.getItem('tokensAuth'));\r\n        if (!tokensActuales?.refresh) {\r\n            cerrarSesion();\r\n            return;\r\n        }\r\n        try {\r\n            const response = await fetch(`${API_URL}/token/refresh/`, { \r\n                method: 'POST', \r\n                headers: { 'Content-Type': 'application/json' }, \r\n                body: JSON.stringify({ 'refresh': tokensActuales.refresh }) \r\n            });\r\n            const data = await response.json();\r\n            if (response.ok) {\r\n                // Se actualiza el token de acceso manteniendo el de refresco\r\n                const nuevosTokens = { ...tokensActuales, access: data.access };\r\n                setTokensAuth(nuevosTokens); \r\n                setUsuario(decodificarToken(data.access));\r\n                localStorage.setItem('tokensAuth', JSON.stringify(nuevosTokens));\r\n            } else { \r\n                // Si el refresh token también falló, cerramos sesión\r\n                cerrarSesion(); \r\n            }\r\n        } catch { \r\n            cerrarSesion(); \r\n        }\r\n    }, [cerrarSesion]);\r\n\r\n    // --- LÓGICA DE REFRESCO INTELIGENTE ---\r\n    useEffect(() => {\r\n        // Si no hay tokens, no hacemos nada.\r\n        if (!tokensAuth) {\r\n            setCargandoInicial(false);\r\n            return;\r\n        }\r\n\r\n        // Decodificamos el token para saber cuándo expira.\r\n        const tokenInfo = decodificarToken(tokensAuth.access);\r\n        const ahora = Date.now() / 1000; // Tiempo actual en segundos\r\n\r\n        // El tiempo de vida del token es la fecha de expiración menos el tiempo actual.\r\n        // Restamos 60 segundos para refrescar 1 minuto antes y evitar problemas.\r\n        let tiempoRestante = (tokenInfo.exp - ahora - 60) * 1000;\r\n        \r\n        // Nos aseguramos de no tener tiempos negativos\r\n        if (tiempoRestante < 0) tiempoRestante = 0;\r\n\r\n        // Creamos un temporizador que llamará a actualizarToken()\r\n        const timeout = setTimeout(() => {\r\n            actualizarToken();\r\n        }, tiempoRestante);\r\n\r\n        // Se marca la carga inicial como completa\r\n        setCargandoInicial(false);\r\n\r\n        // Limpiamos el temporizador si el componente se desmonta o los tokens cambian\r\n        return () => clearTimeout(timeout);\r\n\r\n    }, [tokensAuth, actualizarToken]);\r\n\r\n    // Memorizamos el valor del contexto para evitar re-renders innecesarios en los componentes hijos\r\n    const datosContexto = useMemo(() => ({ \r\n        usuario, \r\n        tokensAuth, \r\n        iniciarSesion, \r\n        cerrarSesion \r\n    }), [usuario, tokensAuth, cerrarSesion]);\r\n\r\n    return (\r\n        <ContextoAuth.Provider value={datosContexto}>\r\n            {cargandoInicial ? <div className=\"min-h-screen flex items-center justify-center\">Cargando...</div> : children}\r\n        </ContextoAuth.Provider>\r\n    );\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}